# -*- coding: utf-8 -*-
"""EstadosProcesso.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v7F1Nl8AoEUhX-YfPZJyjDsrPnrbi9Hu
"""

import time  # Importa a biblioteca time para controle de tempo
import random  # Importa a biblioteca random para gerar escolhas aleatórias
from enum import Enum  # Importa Enum para definir estados de processos

#Andrew Tenenbaum - Sistemas Operacionais Modernos
#Linus Torvalds - criador do Linux
#Helsinki University of Technology

class ProcessState(Enum):  # Define os possíveis estados de um processo
    NEW = "Novo"  # Estado de novo processo
    READY = "Pronto"  # Estado de pronto para execução
    RUNNING = "Executando"  # Estado de execução
    WAITING = "Esperando"  # Estado de espera
    TERMINATED = "Finalizado"  # Estado de finalização

class Process:
    def __init__(self, pid, priority):  # Inicializa um processo com um ID e prioridade
        self.pid = pid  # Define o identificador do processo
        self.state = ProcessState.NEW  # Define o estado inicial como "Novo"
        self.cpu = None  # Inicializa a CPU como None
        self.priority = priority  # Define a prioridade do processo

    def transition(self, used_cpus):  # Define a transição de estados do processo
        if self.state == ProcessState.NEW:  # Se o estado for "Novo"
            self.state = ProcessState.READY  # Transita para "Pronto"
        elif self.state == ProcessState.READY:  # Se o estado for "Pronto"
            available_cpus = [cpu for cpu in range(1, 5) if cpu not in used_cpus]  # Obtém CPUs disponíveis
            if available_cpus:  # Se houver CPUs disponíveis
                self.state = ProcessState.RUNNING  # Transita para "Executando"
                self.cpu = random.choice(available_cpus)  # Atribui uma CPU disponível
                used_cpus.add(self.cpu)  # Marca a CPU como usada
        elif self.state == ProcessState.RUNNING:  # Se o estado for "Executando"
            self.state = random.choice([ProcessState.WAITING, ProcessState.TERMINATED])  # Escolhe aleatoriamente entre "Esperando" ou "Finalizado"
            if self.state == ProcessState.TERMINATED or self.state == ProcessState.WAITING:
                used_cpus.discard(self.cpu)  # Libera a CPU quando o processo sai do estado "Executando"
                self.cpu = None  # Remove a CPU associada
        elif self.state == ProcessState.WAITING:  # Se o estado for "Esperando"
            self.state = ProcessState.READY  # Transita para "Pronto" novamente

    def __str__(self):  # Define a representação textual do processo
        cpu_info = f" na CPU {self.cpu}" if self.cpu else ""
        return f"Processo {self.pid} (Prioridade {self.priority}): {self.state.value}{cpu_info}"  # Retorna o ID, prioridade, estado e CPU do processo

def main():  # Função principal do programa
    processes = [Process(pid, random.randint(1, 5)) for pid in range(1, 6)]  # Cria uma lista de 5 processos com prioridades aleatórias

    while any(p.state != ProcessState.TERMINATED for p in processes):  # Continua enquanto houver processos não finalizados
        processes.sort(key=lambda p: p.priority)  # Ordena os processos por prioridade (menor valor = maior prioridade)
        used_cpus = set()  # Conjunto para rastrear CPUs em uso

        for process in processes:  # Itera sobre os processos
            if process.state != ProcessState.TERMINATED:  # Se o processo não estiver finalizado
                process.transition(used_cpus)  # Faz a transição de estado evitando conflitos de CPU
                print(process)  # Exibe o estado atual do processo
        print("-" * 30)  # Imprime um separador visual
        time.sleep(1)  # Aguarda 1 segundo antes da próxima iteração

if __name__ == "__main__":  # Verifica se o script está sendo executado diretamente
    main()  # Chama a função principal

